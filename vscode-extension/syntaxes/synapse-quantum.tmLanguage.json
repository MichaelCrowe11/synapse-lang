{
  "name": "Synapse Quantum Language",
  "scopeName": "source.synapse",
  "fileTypes": ["syn", "synapse"],
  "patterns": [
    {
      "include": "#quantum-keywords"
    },
    {
      "include": "#parallel-blocks"
    },
    {
      "include": "#uncertainty-types"
    },
    {
      "include": "#reasoning-chains"
    },
    {
      "include": "#tensor-operations"
    },
    {
      "include": "#quantum-gates"
    },
    {
      "include": "#quantum-states"
    },
    {
      "include": "#comments"
    },
    {
      "include": "#strings"
    },
    {
      "include": "#numbers"
    },
    {
      "include": "#operators"
    },
    {
      "include": "#functions"
    },
    {
      "include": "#variables"
    }
  ],
  "repository": {
    "quantum-keywords": {
      "patterns": [
        {
          "name": "keyword.control.quantum.synapse",
          "match": "\\b(quantum|circuit|qubit|qubits|measure|entangle|superposition|teleport|oracle|amplitude)\\b"
        },
        {
          "name": "keyword.control.experiment.synapse",
          "match": "\\b(experiment|pipeline|stage|hypothesis|observe|conclude|verify)\\b"
        },
        {
          "name": "keyword.control.flow.synapse",
          "match": "\\b(if|else|elif|while|for|in|range|repeat|break|continue|return)\\b"
        },
        {
          "name": "keyword.control.parallel.synapse",
          "match": "\\b(parallel|branch|fork|join|synthesize|thread|async|await)\\b"
        }
      ]
    },
    "parallel-blocks": {
      "name": "meta.parallel.synapse",
      "begin": "\\b(parallel)\\s*\\{",
      "end": "\\}",
      "patterns": [
        {
          "name": "keyword.control.branch.synapse",
          "match": "\\b(branch)\\s+(\\w+)\\s*:",
          "captures": {
            "1": {
              "name": "keyword.control.synapse"
            },
            "2": {
              "name": "entity.name.function.synapse"
            }
          }
        },
        {
          "include": "$self"
        }
      ]
    },
    "uncertainty-types": {
      "patterns": [
        {
          "name": "storage.type.uncertainty.synapse",
          "match": "\\b(uncertain|measurement|probability|confidence)\\b"
        },
        {
          "name": "constant.numeric.uncertainty.synapse",
          "match": "\\b(\\d+\\.?\\d*)\\s*±\\s*(\\d+\\.?\\d*)\\b",
          "captures": {
            "1": {
              "name": "constant.numeric.value.synapse"
            },
            "2": {
              "name": "constant.numeric.error.synapse"
            }
          }
        }
      ]
    },
    "reasoning-chains": {
      "name": "meta.reasoning.synapse",
      "begin": "\\b(reason)\\s+(chain)\\s+(\\w+)\\s*\\{",
      "end": "\\}",
      "beginCaptures": {
        "1": {
          "name": "keyword.control.synapse"
        },
        "2": {
          "name": "keyword.control.synapse"
        },
        "3": {
          "name": "entity.name.class.synapse"
        }
      },
      "patterns": [
        {
          "name": "keyword.control.logic.synapse",
          "match": "\\b(premise|derive|conclude|from|implies|contradicts)\\b"
        },
        {
          "include": "$self"
        }
      ]
    },
    "tensor-operations": {
      "patterns": [
        {
          "name": "keyword.operator.tensor.synapse",
          "match": "⊗|⊕|⊙|⊘"
        },
        {
          "name": "storage.type.tensor.synapse",
          "match": "\\b(tensor|matrix|vector|scalar)\\b"
        },
        {
          "name": "support.function.tensor.synapse",
          "match": "\\b(dot|cross|einsum|reshape|transpose|convolve)\\b"
        }
      ]
    },
    "quantum-gates": {
      "patterns": [
        {
          "name": "support.function.quantum.gate.synapse",
          "match": "\\b(H|X|Y|Z|S|T|CNOT|CZ|SWAP|TOFFOLI|FREDKIN|RX|RY|RZ|QFT|IQFT)\\b"
        },
        {
          "name": "support.function.quantum.composite.synapse",
          "match": "\\b(bell_pair|ghz_state|w_state|cluster_state)\\b"
        }
      ]
    },
    "quantum-states": {
      "patterns": [
        {
          "name": "constant.language.quantum.state.synapse",
          "match": "\\|[01]+⟩"
        },
        {
          "name": "constant.language.quantum.bra.synapse",
          "match": "⟨[01]+\\|"
        },
        {
          "name": "constant.language.quantum.special.synapse",
          "match": "\\|[\\+\\-]⟩|\\|[ij]⟩|\\|ψ⟩|\\|φ⟩|\\|Φ[\\+\\-]?⟩|\\|Ψ[\\+\\-]?⟩"
        }
      ]
    },
    "comments": {
      "patterns": [
        {
          "name": "comment.line.double-slash.synapse",
          "match": "//.*$"
        },
        {
          "name": "comment.block.synapse",
          "begin": "/\\*",
          "end": "\\*/"
        }
      ]
    },
    "strings": {
      "patterns": [
        {
          "name": "string.quoted.double.synapse",
          "begin": "\"",
          "end": "\"",
          "patterns": [
            {
              "name": "constant.character.escape.synapse",
              "match": "\\\\."
            }
          ]
        },
        {
          "name": "string.quoted.single.synapse",
          "begin": "'",
          "end": "'",
          "patterns": [
            {
              "name": "constant.character.escape.synapse",
              "match": "\\\\."
            }
          ]
        },
        {
          "name": "string.quoted.triple.synapse",
          "begin": "\"\"\"",
          "end": "\"\"\""
        }
      ]
    },
    "numbers": {
      "patterns": [
        {
          "name": "constant.numeric.float.synapse",
          "match": "\\b\\d+\\.\\d+([eE][+-]?\\d+)?\\b"
        },
        {
          "name": "constant.numeric.integer.synapse",
          "match": "\\b\\d+\\b"
        },
        {
          "name": "constant.numeric.hex.synapse",
          "match": "\\b0[xX][0-9a-fA-F]+\\b"
        },
        {
          "name": "constant.numeric.binary.synapse",
          "match": "\\b0[bB][01]+\\b"
        },
        {
          "name": "constant.numeric.complex.synapse",
          "match": "\\b\\d+(\\.\\d+)?[ij]\\b"
        }
      ]
    },
    "operators": {
      "patterns": [
        {
          "name": "keyword.operator.arithmetic.synapse",
          "match": "\\+|\\-|\\*|\\/|\\%|\\^|\\*\\*"
        },
        {
          "name": "keyword.operator.comparison.synapse",
          "match": "==|!=|<=|>=|<|>"
        },
        {
          "name": "keyword.operator.logical.synapse",
          "match": "\\b(and|or|not|xor)\\b|&&|\\|\\||!"
        },
        {
          "name": "keyword.operator.assignment.synapse",
          "match": "=|\\+=|\\-=|\\*=|\\/=|\\%="
        },
        {
          "name": "keyword.operator.arrow.synapse",
          "match": "=>|->|<-|<->"
        }
      ]
    },
    "functions": {
      "patterns": [
        {
          "name": "entity.name.function.synapse",
          "match": "\\b([a-zA-Z_][a-zA-Z0-9_]*)\\s*\\(",
          "captures": {
            "1": {
              "name": "entity.name.function.synapse"
            }
          }
        },
        {
          "name": "storage.type.function.synapse",
          "match": "\\b(function|func|def|procedure|method)\\b"
        }
      ]
    },
    "variables": {
      "patterns": [
        {
          "name": "variable.language.synapse",
          "match": "\\b(self|this|super)\\b"
        },
        {
          "name": "constant.language.synapse",
          "match": "\\b(true|false|null|none|π|e|i|j)\\b"
        },
        {
          "name": "storage.type.synapse",
          "match": "\\b(int|float|complex|bool|string|array|list|dict|set)\\b"
        }
      ]
    }
  }
}